<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="13.0.3">
<procedure name="main">
<interface/>
<body>
<l>ToolName := 'Edge Counter Arc'</l>
<c></c>
<l>ArrayCount := 1</l>
<c></c>
<l>Crosses_Region_Color := [0, 0, 255, 255]</l>
<l>Arc_Region_Color := [255, 0, 0, 255]</l>
<c></c>
<l>AmplitudeThreshold_Int := 2</l>
<l>RoiWidthLength_Int := 5</l>
<l>Sigma_Real := 1.0</l>
<c></c>
<l>Transition_Enum_Values := ['all', 'positive', 'negative']</l>
<l>Transition_Enum := 'all'</l>
<c></c>
<l>Select_Enum_Values := ['all', 'first', 'last']</l>
<l>Select_Enum := 'all'</l>
<c></c>
<l>ArcCenterX_Int := 100</l>
<l>ArcCenterY_Int := 100</l>
<l>ArcRadius_Int := 50</l>
<l>ArcAngleStart_Int := 0</l>
<l>ArcAngleExtent_Int := 90</l>
<c></c>
<l>UseCalibration_MBool := false</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="HalconRun">
<interface>
<io>
<par name="InputImage_Img" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="Arc_Region" base_type="iconic" dimension="0"/>
<par name="Crosses_Region" base_type="iconic" dimension="0"/>
<par name="OutputImage_Img" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="ArcCenterX_Int" base_type="ctrl" dimension="0"/>
<par name="ArcCenterY_Int" base_type="ctrl" dimension="0"/>
<par name="ArcRadius_Int" base_type="ctrl" dimension="0"/>
<par name="ArcAngleStart_Int" base_type="ctrl" dimension="0"/>
<par name="ArcAngleExtent_Int" base_type="ctrl" dimension="0"/>
<par name="AmplitudeThreshold_Int" base_type="ctrl" dimension="0"/>
<par name="RoiWidthLength_Int" base_type="ctrl" dimension="0"/>
<par name="Sigma_Real" base_type="ctrl" dimension="0"/>
<par name="Transition_Enum" base_type="ctrl" dimension="0"/>
<par name="Select_Enum" base_type="ctrl" dimension="0"/>
<par name="UseCalibration_MBool" base_type="ctrl" dimension="0"/>
<par name="InputImage_Img_Calib" base_type="ctrl" dimension="0"/>
<par name="InputImage_Img_Trafo" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="NumberOfEdges_Int" base_type="ctrl" dimension="0"/>
<par name="DistancePeakToPeak_Real" base_type="ctrl" dimension="0"/>
<par name="PositionX_RealArray" base_type="ctrl" dimension="0"/>
<par name="PositionY_RealArray" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>if (UseCalibration_MBool == true)</l>
<l>    CamParam := InputImage_Img_Calib[0:7]</l>
<l>    CamPose := InputImage_Img_Calib[8:14]</l>
<l>endif</l>
<c></c>
<l>PositionX_RealArray := 0</l>
<l>PositionY_RealArray := 0</l>
<l>NumberOfEdges_Int := 0</l>
<l>DistancePeakToPeak_Real := 0</l>
<c></c>
<l>PositionXCalibrated_RealArray := 0</l>
<l>PositionYCalibrated_RealArray := 0</l>
<l>DistancePeakToPeakCalibrated_Real := 0</l>
<c></c>
<l>affine_trans_image (InputImage_Img, OutputImage_Img, InputImage_Img_Trafo, 'constant', 'false')</l>
<c></c>
<l>get_image_size (OutputImage_Img, Width, Height)</l>
<c></c>
<l>gen_circle (Circ1, ArcCenterY_Int, ArcCenterX_Int, ArcRadius_Int + 2)</l>
<l>gen_circle (Circ2, ArcCenterY_Int, ArcCenterX_Int, ArcRadius_Int - 2)</l>
<l>difference (Circ1, Circ2, Donut)</l>
<c></c>
<l>zakres := 360 - ArcAngleExtent_Int</l>
<l>for k := 1 to zakres by 1</l>
<l>Xo := ArcRadius_Int * cos(rad(ArcAngleStart_Int + ArcAngleExtent_Int + k))</l>
<l>Yo := ArcRadius_Int * sin(rad(ArcAngleStart_Int + ArcAngleExtent_Int + k))</l>
<c>    </c>
<l>    Xo := Xo + ArcCenterX_Int</l>
<l>    Yo := -Yo</l>
<l>    Yo := Yo + ArcCenterY_Int</l>
<c>      </c>
<l>    gen_circle (Circle, Yo, Xo, 4)</l>
<l>    difference (Donut, Circle, Donut)</l>
<l>endfor</l>
<c></c>
<l>Arc_Region := Donut</l>
<c></c>
<l as_id="measure1d" as_name="Measure 01" as_grp="[2,1]" as_ord="2">AmplitudeThreshold := AmplitudeThreshold_Int</l>
<l as_id="measure1d" as_name="Measure 01" as_grp="[2,1]" as_ord="3">RoiWidthLen2 := RoiWidthLength_Int</l>
<c></c>
<l as_id="measure1d" as_name="Measure 01" as_grp="[2,2]" as_ord="2">ArcRow_Measure_01_0 := ArcCenterY_Int</l>
<l>ArcColumn_Measure_01_0 := ArcCenterX_Int</l>
<l>ArcRadius_Measure_01_0 := ArcRadius_Int</l>
<c></c>
<l>if (ArcAngleStart_Int &gt; 0 and ArcAngleStart_Int &lt; 180)</l>
<l>    ArcStart := rad(ArcAngleStart_Int)</l>
<l>elseif (ArcAngleStart_Int &gt; 180 and ArcAngleStart_Int &lt; 360)</l>
<l>    ArcStart := 360 - ArcAngleStart_Int</l>
<l>    ArcStart := rad(ArcStart)</l>
<l>    ArcStart := -ArcStart</l>
<l>elseif (ArcAngleStart_Int == 180)</l>
<l>    ArcStart := 3.14</l>
<l>elseif (ArcAngleStart_Int == 0)</l>
<l>    ArcStart := 0</l>
<l>elseif (ArcAngleStart_Int == 360)</l>
<l>    ArcStart := 6.28</l>
<l>endif</l>
<c></c>
<l>ArcEnd := rad(ArcAngleExtent_Int)</l>
<c></c>
<l>ArcAngleStart_Measure_01_0 := ArcStart</l>
<l>ArcAngleExtent_Measure_01_0 := ArcEnd</l>
<c></c>
<l>gen_measure_arc (ArcRow_Measure_01_0, ArcColumn_Measure_01_0, ArcRadius_Measure_01_0, ArcAngleStart_Measure_01_0, ArcAngleExtent_Measure_01_0, max2(1, min2(RoiWidthLen2, ArcRadius_Measure_01_0)), Width, Height, 'nearest_neighbor', MsrHandle_Measure_01_0)</l>
<l>measure_pos (OutputImage_Img, MsrHandle_Measure_01_0, Sigma_Real, AmplitudeThreshold, Transition_Enum[1], Select_Enum[1], Row_Measure_01_0, Column_Measure_01_0, Amplitude_Measure_01_0, Distance_Measure_01_0)</l>
<l>gen_empty_region (Region2)</l>
<c></c>
<l>if(|Column_Measure_01_0| &gt; 1)</l>
<l>    NumberOfEdges_Int := |Row_Measure_01_0|    </l>
<l>    PositionX_RealArray := Column_Measure_01_0[0:|Column_Measure_01_0|-1]</l>
<l>    PositionY_RealArray := Row_Measure_01_0[0:|Column_Measure_01_0|-1]   </l>
<l>    DistancePeakToPeak_Real := sum(Distance_Measure_01_0)</l>
<c>    </c>
<l>    if (UseCalibration_MBool == true)</l>
<l>        image_points_to_world_plane (CamParam, CamPose, PositionY_RealArray, PositionX_RealArray, 'mm', PositionXCalibrated_RealArray, PositionYCalibrated_RealArray)</l>
<l>        distance_pp (PositionYCalibrated_RealArray[0], PositionXCalibrated_RealArray[0], PositionYCalibrated_RealArray[NumberOfEdges_Int - 1], PositionXCalibrated_RealArray[NumberOfEdges_Int - 1], DistancePeakToPeakCalibrated_Real)</l>
<l>    endif</l>
<c>            </c>
<l>    for CrossIndex := 1 to |Column_Measure_01_0| by 1 </l>
<l>        gen_rectangle2 (ROI_0, Row_Measure_01_0[CrossIndex-1], Column_Measure_01_0[CrossIndex-1], rad(45), 1, 8)</l>
<l>        gen_rectangle2 (ROI_1, Row_Measure_01_0[CrossIndex-1], Column_Measure_01_0[CrossIndex-1], rad(-45), 1, 8)</l>
<l>        union2 (ROI_0, ROI_1, Region1)</l>
<l>        union2 (Region1, Region2, Region2)     </l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<l>if(|Column_Measure_01_0| == 1)</l>
<l>    NumberOfEdges_Int := |Row_Measure_01_0|    </l>
<l>    PositionX_RealArray := Column_Measure_01_0[0:|Column_Measure_01_0|-1]</l>
<l>    PositionY_RealArray := Row_Measure_01_0[0:|Column_Measure_01_0|-1]   </l>
<l>    DistancePeakToPeak_Real := 0</l>
<c>    </c>
<l>    if (UseCalibration_MBool == true)</l>
<l>        image_points_to_world_plane (CamParam, CamPose, PositionY_RealArray, PositionX_RealArray, 'mm', PositionXCalibrated_RealArray, PositionYCalibrated_RealArray)</l>
<l>    endif</l>
<c>            </c>
<l>    for CrossIndex := 1 to |Column_Measure_01_0| by 1 </l>
<l>        gen_rectangle2 (ROI_0, Row_Measure_01_0[CrossIndex-1], Column_Measure_01_0[CrossIndex-1], rad(45), 1, 8)</l>
<l>        gen_rectangle2 (ROI_1, Row_Measure_01_0[CrossIndex-1], Column_Measure_01_0[CrossIndex-1], rad(-45), 1, 8)</l>
<l>        union2 (ROI_0, ROI_1, Region1)</l>
<l>        union2 (Region1, Region2, Region2)     </l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<l>Crosses_Region := Region2</l>
<c></c>
<l>close_measure (MsrHandle_Measure_01_0)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="HalconRun">
<parameters>
<parameter id="AmplitudeThreshold_Int"/>
<parameter id="ArcAngleExtent_Int"/>
<parameter id="ArcAngleStart_Int"/>
<parameter id="ArcCenterX_Int"/>
<parameter id="ArcCenterY_Int"/>
<parameter id="ArcRadius_Int"/>
<parameter id="Arc_Region"/>
<parameter id="Crosses_Region"/>
<parameter id="DistancePeakToPeak_Real"/>
<parameter id="InputImage_Img"/>
<parameter id="InputImage_Img_Calib"/>
<parameter id="InputImage_Img_Trafo"/>
<parameter id="NumberOfEdges_Int"/>
<parameter id="OutputImage_Img"/>
<parameter id="PositionX_RealArray"/>
<parameter id="PositionY_RealArray"/>
<parameter id="RoiWidthLength_Int"/>
<parameter id="Select_Enum"/>
<parameter id="Sigma_Real"/>
<parameter id="Transition_Enum"/>
<parameter id="UseCalibration_MBool"/>
</parameters>
</docu>
</procedure>
</hdevelop>
